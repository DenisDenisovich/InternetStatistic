package aero.testcompany.internetstat.domain.malware

import aero.testcompany.internetstat.domain.network.GetPackageNetworkForDayUseCase
import aero.testcompany.internetstat.domain.packageinfo.GetPackageUidUseCase
import aero.testcompany.internetstat.domain.packageinfo.GetPackagesUseCase
import aero.testcompany.internetstat.models.MyPackageInfo
import android.app.usage.NetworkStatsManager
import android.content.Context
import android.util.Log
import kotlinx.coroutines.*

class MalwareScanner(private val context: Context) {

    var suspectCallback: ((ArrayList<SuspectApp>) -> Unit)? = null

    private val job = Job()
    private val scope = CoroutineScope(Dispatchers.Default + job)
    private val networkStartManager =
        context.getSystemService(Context.NETWORK_STATS_SERVICE) as NetworkStatsManager
    private val packageUid = GetPackageUidUseCase(context)
    private val calculators: HashMap<String, GetPackageNetworkForDayUseCase> = HashMap()
    private var packagesList = ArrayList<MyPackageInfo>()
    private val packagesListUseCase = GetPackagesUseCase(context.packageManager)

    private val suspectedApps: ArrayList<SuspectApp> = arrayListOf()
    fun start() {
        scope.launch {
            val calcWorks = ArrayList<Deferred<Pair<Long, Long>>>()
            calcWorks.clear()
            updateCalculatorsList()
            getAppData()
            sendSuspectApps()
        }
    }

    private fun updateCalculatorsList() {
        packagesList = ArrayList(packagesListUseCase.getPackages())
        packagesList.forEach {
            calculators[it.packageName] = GetPackageNetworkForDayUseCase(
                packageUid.getUid(it.packageName),
                context,
                networkStartManager
            )
        }
    }

    private suspend fun getAppData() {
        suspectedApps.clear()
        calculators.forEach { (packageId, calculator) ->
            val data = calculator.startNow(scope)
            var backSum = 0L
            var forSum = 0L
            var allReceived = 0L
            var allTransmitted = 0L
            var rt = 1.0
            var fb = 1.0
            data.forEach {
                //Log.d("LogMalwareCheck", "$packageId, $it")
                allReceived += it.all.wifi.received + it.all.mobile.received
                allTransmitted += it.all.wifi.transmitted + it.all.mobile.transmitted
                backSum += it.getBackgroundTraffic()
                forSum += it.getForegroundTraffic()
            }
            if (allTransmitted != 0L) {
                rt = allReceived.toDouble() / allTransmitted
            }
            if (backSum != 0L) {
                fb = forSum.toDouble() / backSum
            }
            val isMalware = rt != 1.0 && fb != 1.0 && rt < RT_COEFF && fb < FB_COEFF
            if (isMalware) {
                suspectedApps.add(
                    SuspectApp(
                        packageId,
                        rt,
                        fb,
                        backSum,
                        forSum,
                        allReceived,
                        allTransmitted
                    )
                )
            }
            Log.d(
                "LogMalware",
                "$packageId, $isMalware $rt = $allReceived / $allTransmitted, $fb = $forSum / $backSum"
            )
        }
    }

    suspend fun sendSuspectApps() {
        if (suspectedApps.isNotEmpty()) {
            suspectCallback?.invoke(suspectedApps)
        }
        suspectedApps.forEach {
            Log.d("LogMalwareCheck", it.toString())
        }
    }

    companion object {
        const val RT_COEFF = 0.05
        const val FB_COEFF = 0.001
    }
}